<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch00-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="ch01-00-key-concepts.html"><strong aria-hidden="true">2.</strong> Key Concepts</a></li><li><ol class="section"><li><a href="ch01-01-flat-tree.html"><strong aria-hidden="true">2.1.</strong> Flat Tree</a></li><li><a href="ch01-02-merkle-tree.html"><strong aria-hidden="true">2.2.</strong> Merkle Tree</a></li><li><a href="ch01-03-bitfield.html"><strong aria-hidden="true">2.3.</strong> Bitfield</a></li><li><a href="ch01-04-storage.html"><strong aria-hidden="true">2.4.</strong> Storage</a></li></ol></li><li><a href="ch02-00-implementation-guide.html"><strong aria-hidden="true">3.</strong> Implementation Guide</a></li><li><a href="ch03-00-appendix.html"><strong aria-hidden="true">4.</strong> Appendix</a></li><li><ol class="section"><li><a href="ch03-01-terminology.html"><strong aria-hidden="true">4.1.</strong> A - Terminology</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>Welcome to <em>The Dat Protocol</em>, a technical book about <a href="https://datproject.org/">The Dat
Project</a>. The Dat protocol is a p2p hypermedia
protocol. It provides public-key-addressed file archives which can be synced
securely and browsed on-demand.</p>
<a class="header" href="#who-this-book-is-for" id="who-this-book-is-for"><h2>Who This Book Is For</h2></a>
<p>This book is written for people interested in understanding the details of the
Dat protocol, and potentially implementing parts of it themselves. We go into
details about the different components that make up the protocol, and provide
guidance on how to approach an implementation yourself.</p>
<p>This book is different from the <a href="https://www.datprotocol.com/deps/">Dat Enhancement Proposals
(DEPs)</a>. DEPs focus on creating
standardization and specification of the Dat protocol. This book focuses on
providing an introduction to key concepts, and guidance on how to implement
them.</p>
<a class="header" href="#source-code" id="source-code"><h2>Source Code</h2></a>
<p>The source files from which this book is generated can be found on
<a href="https://github.com/datprotocol/book">GitHub</a>.</p>
<a class="header" href="#key-concepts" id="key-concepts"><h1>Key Concepts</h1></a>
<p>In this section we'll introduce you to the conceptual components that make up
the Dat protocol. You don't need to know these to create your first Dat archive,
but they're essential if you're trying to understand what happens at the
protocol level.</p>
<a class="header" href="#flat-tree" id="flat-tree"><h1>Flat Tree</h1></a>
<p>Flat Trees are the core data structure that powers the Dat protocol.</p>
<a class="header" href="#thinking-about-flat-trees" id="thinking-about-flat-trees"><h2>Thinking About Flat Trees</h2></a>
<p>You can represent a binary tree in a simple flat list using the following
structure:</p>
<pre><code class="language-txt">      3
  1       5
0   2   4   6  ...
</code></pre>
<p>Let's rotate the tree on its side for notational purposes:</p>
<pre><code class="language-txt"> 0─┐
   1─┐
 2─┘ │
     3
 4─┐ │
   5─┘
 6─┘
</code></pre>
<p>Each number represents an <strong>index</strong> in a flat list. Given the tree:</p>
<pre><code class="language-txt"> D─┐
   B─┐
 E─┘ │
     A
 F─┐ │
   C─┘
 G─┘
</code></pre>
<p>The way this would be expressed in-memory would be as the list (vector):
<code>[D B E A F C G]</code> or <code>[0 1 2 3 4 5 6]</code>.</p>
<a class="header" href="#depth" id="depth"><h2>Depth</h2></a>
<p>Indexes 0, 2, 4, 6 have a depth of 0. And indexes 1, 5, 9 have a depth of 1.</p>
<pre><code class="language-text">depth = 2  ^        3
depth = 1  |    1       5
depth = 0  |  0   2   4   6  ...
</code></pre>
<p>If we convert the graph to a chart we could express it as such:</p>
<pre><code class="language-text">depth = 0 | 0 2 4 6
depth = 1 | 1 5
depth = 2 | 3
depth = 3 |
</code></pre>
<p>Now let's add numbers up to 14:</p>
<pre><code class="language-text">depth = 0 | 0 2 4 6 8 10 12 14
depth = 1 | 1 5 9 13
depth = 2 | 3 11
depth = 3 | 7
</code></pre>
<a class="header" href="#node-kinds" id="node-kinds"><h3>Node Kinds</h3></a>
<p>You might be noticing that the numbers at <code>depth = 0</code> is vastly greater than the
amount of numbers at every other depth. We refer to nodes at <code>depth = 0</code> as
<code>leaf nodes</code>, and nodes at every other depth as <code>parent nodes</code>.</p>
<pre><code class="language-text">leaf nodes   | 0 2 4 6 8 10 12 14
parent nodes | 1 3 5 7 9 11 13
</code></pre>
<p>An interesting aspect of flat trees is that the number of <code>leaf nodes</code> and
number of <code>parent nodes</code> is in perfect balance. This comes to an interesting
insight:</p>
<ul>
<li>All <strong>even indexes</strong> refer to <code>leaf nodes</code>.</li>
<li>All <strong>uneven indexes</strong> refer to <code>parent nodes</code>.</li>
</ul>
<p>The depth of a tree node can be calculated by counting the number of trailing 1s
a node has in binary notation.</p>
<pre><code class="language-txt">5 in binary = 101 (one trailing 1)
3 in binary = 011 (two trailing 1s)
4 in binary = 100 (zero trailing 1s)
</code></pre>
<a class="header" href="#offset" id="offset"><h2>Offset</h2></a>
<p>When reading about flat-trees the word <code>offset</code> might regularly pop up. This
refers to the offset from the left hand side of the tree.</p>
<p>In the following tree the indexes with an offset of 0 are: <code>[0 1 3 7]</code>:</p>
<pre><code class="language-text">(0)┐
  (1)┐
 2─┘ │
    (3)┐
 4─┐ │ │
   5─┘ │
 6─┘   │
      (7)
</code></pre>
<p>In the next tree the indexes with an offset of 1 are: <code>[2 5 11]</code>:</p>
<pre><code class="language-text">  0──┐
     1──┐
 (2)─┘  │
        3──┐
  4──┐  │  │
    (5)─┘  │
  6──┘     │
           7
  8──┐     │
     9──┐  │
 10──┘  │  │
      (11)─┘
 12──┐  │
    13──┘
 14──┘
</code></pre>
<a class="header" href="#relationships-between-nodes" id="relationships-between-nodes"><h2>Relationships Between Nodes</h2></a>
<p>When describing nodes we often also talk about the relationship between nodes.
This includes words such as <code>uncle</code>, and <code>parent</code>.</p>
<p>Take this example tree:</p>
<pre><code class="language-txt"> 0─┐
   1─┐
 2─┘ │
     3─┐
 4─┐ │ │
   5─┘ │
 6─┘   │
       7
 8
</code></pre>
<ul>
<li><strong>parent:</strong> A parent has two children under it, and is always odd-numbered.
Node 3 is the parent of 1 and 5.</li>
<li><strong>leaf:</strong> A node with no children. A leaf node is always even-numbered.
Nodes 0, 2, 4, 6 and 8 are leaf nodes.</li>
<li><strong>sibling:</strong> The other node that shares a parent with the current node. For
example nodes 4 and 6 are siblings.</li>
<li><strong>uncle:</strong> A parent's sibling. Node 1 is the uncle of nodes 4 and 6.</li>
<li><strong>root:</strong> A top-most node where the full tree under it is complete (e.g. all
parent nodes have 2 children). Node 3 is a root node.</li>
<li><strong>span:</strong> The two nodes that are furthest away in the sub-tree. The span of
node 1 is <code>0, 2</code>. The span of node 3 is <code>0, 6</code>.</li>
<li><strong>right span:</strong> The left-most node in the span. The right span of node 1 is 2.
The right span of node 3 is 6.</li>
</ul>
<a class="header" href="#references" id="references"><h2>References</h2></a>
<ul>
<li>https://gist.github.com/jimpick/54adc72f11f38f1fe4bc1d45d3981708</li>
<li>https://github.com/jimpick/hypercore-simple-ipld/blob/master/tree-test.js</li>
<li>https://datatracker.ietf.org/doc/rfc7574/?include_text=1</li>
<li>https://www.datprotocol.com/deps/0002-hypercore/</li>
</ul>
<a class="header" href="#merkle-tree" id="merkle-tree"><h1>Merkle Tree</h1></a>
<p>Merkle Trees in Dat are specialized <a href="./ch01-01-flat-tree">Flat Trees</a> that
contain the content of the archives.</p>
<p>In this section we'll cover how Merkle Trees work, and how we use them inside
Hypercore.</p>
<a class="header" href="#what-are-merkle-trees" id="what-are-merkle-trees"><h2>What Are Merkle Trees?</h2></a>
<p>Wikipedia defines a Merkle Tree as:</p>
<blockquote>
<p>A hash tree or Merkle tree is a tree in which every leaf node is labelled with
the hash of a data block and every non-leaf node is labelled with the
cryptographic hash of the labels of its child nodes.</p>
</blockquote>
<p>In <code>flat-tree</code> terminology this means all leaf nodes (even numbers) contain
hashes of data, and all uneven numbers (parent nodes) contain hashes.</p>
<p>Take the following tree:</p>
<pre><code class="language-txt">  0──┐
     1──┐
  2──┘  │
        3
  4──┐  │
     5──┘
  6──┘
</code></pre>
<ul>
<li>Nodes 0, 2, 4, and 6 contain the hashes of data.</li>
<li>Node 1 contains the hash of hashes from nodes 0 and 2.</li>
<li>Node 5 contains the hash of hashes from nodes 4 and 6.</li>
<li>Node 3 contains the hash of hashes from nodes 1 and 5.</li>
</ul>
<a class="header" href="#hypercore-files" id="hypercore-files"><h2>Hypercore Files</h2></a>
<p>A Hypercore's internal structure typically typically of these files:</p>
<ul>
<li><strong>data:</strong> a file containing the data added to the Hypercore.</li>
<li><strong>tree:</strong> a file containing the Merkle tree of hashes derived from the data.</li>
<li><strong>signatures:</strong> a file containing the cryptographic signatures of the hashes
in the tree file.</li>
<li><strong>bitfield:</strong> a file to keep track of which data we have locally, and which
data is part of the network.</li>
<li><strong>public key:</strong> a file containing the public key. This is used for verifying
content.</li>
<li><strong>secret key:</strong> a file containing the signing key. This is used for adding new
content, and is only available on Hypercores you've created.</li>
</ul>
<blockquote>
<p>The names we're using to refer to files here is also the way they're referred
to in Hypercore's specs and implementations. When inspecting a <code>.dat</code>
directory you'll see see these terms used as suffixes. For example
as <code>content.tree</code>, or <code>metadata.signatures</code>.</p>
</blockquote>
<p>The tree file is responsible of verifying the integrity of the data that's
being appended to the feed.</p>
<p>The signature file is responsible for ensuring the integrity of the entire tree
at any given state. Every entry in the signature file verifies the current state
of the entire tree file.</p>
<blockquote>
<p>Not every Hypercore is the same. In most implementations of Dat it's possible
to choose how data is stored. For server applications it makes sense to store
it in a single file. But for desktop applications it can sometimes make sense
to store content directly on disk. For example in the case of (hyper)media
files.</p>
</blockquote>
<p>Let's look at how these files relate to each other to create a Hypercore feed.</p>
<a class="header" href="#merkle-trees-in-theory" id="merkle-trees-in-theory"><h2>Merkle Trees In Theory</h2></a>
<p>Whenever data is added to Hypercore, a new entry is created in the data file. We
then hash the data, and write that hash to a tree file's leaf node. If the leaf
node has a sibling, the parent node's hash can be computed. If the new parent
node has a sibling, we can compute a new parent node above it. We recurse upward
until no more parent nodes can be computed, at which point we'll have reached a
root node.</p>
<p>When there are no more hashes left to compute, we gather all the root nodes in
the tree, concatenate them, hash them, and sign them with our private key. We
then store the signature in our signatures file at the same index of the leaf
node that was added.</p>
<p>This might all sound a little abstract though, so let's look at an example.</p>
<a class="header" href="#merkle-trees-in-practice" id="merkle-trees-in-practice"><h2>Merkle Trees In Practice</h2></a>
<p>We're starting off with an empty Hypercore feed. We're planning to add 5 pieces
of data to it, one by one: <code>[A B C D]</code>.</p>
<a class="header" href="#entry-1" id="entry-1"><h3>Entry 1</h3></a>
<p>Let's add our first piece of data to Hypercore. We insert the value &quot;A&quot; as our
first entry. The entry index is prefixed with <code>index:</code>. In order, the following
actions happen:</p>
<ol>
<li>We append the data to the data file.</li>
<li>We compute a hash from the data, and store it at index 0 in our tree file.</li>
<li>We gather all root nodes from our tree file (which is just the node at index
0 right now), and compute a cryptographic signature from the hash.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<p><strong>data</strong></p>
<pre><code class="language-txt">1: A
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">1: 0
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">1: 0
</code></pre>
<a class="header" href="#entry-2" id="entry-2"><h3>Entry 2</h3></a>
<p>Let's add our second entry to hypercore. We now have more nodes, which means
things are a little different:</p>
<ol>
<li>We append the data to the data file.</li>
<li>We compute a hash from the data, and store it at index <code>2</code> in our tree file.</li>
<li>Because index <code>2</code> has a sibling hash, we compute a new parent hash, and store
it at index <code>1</code>.</li>
<li>We gather all root nodes from our tree file, and compute a cryptographic
signature from the hash. The only root node currently available is at index
<code>1</code>.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<blockquote>
<p>When we talk about &quot;computing a parent hash&quot; it means we concatenate the
hashes from both child nodes, and hash the result. Hashes are always the same
length, which means every node in the tree is the same length.</p>
</blockquote>
<p><strong>data</strong></p>
<pre><code class="language-txt">1: A
2: B
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">1: 0─┐
     1
2: 2─┘
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">1: sig(0)
2: sig(1)
</code></pre>
<a class="header" href="#entry-3" id="entry-3"><h3>Entry 3</h3></a>
<p>So far so good. We're well on our way to building a full tree-structure! Let's
continue on our journey, and add our third entry: <code>C</code>.</p>
<ol>
<li>We append the third piece data to the data file at index 2.</li>
<li>We compute a hash from the data, and store it at index <code>4</code> in our tree file.</li>
<li>We now have two root hashes: <code>1</code> and <code>4</code>. So we concatenate them, hash the
result, and sign the result.
<code>1</code>.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<p><strong>data</strong></p>
<pre><code class="language-txt">1: index: 0, data: A
2: index: 1, data: B
3: index: 2, data: C
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">1: 0─┐
     1
2: 2─┘

3: 4
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">1: sig(0)
3: sig(1)
3: sig(1 + 4)
</code></pre>
<a class="header" href="#entry-4" id="entry-4"><h3>Entry 4</h3></a>
<p>Let's add the final piece of data to our feed. This will balance out a tree, and
bring us back to only one root hash!</p>
<ol>
<li>We append the fourth piece data to the data file at index <code>3</code>.</li>
<li>We compute a hash from the data, and store it at index <code>6</code> in our tree file.</li>
<li>Our only root node is <code>3</code>, so we compute its hash, sign it, and compute the
signature.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<p><strong>data</strong></p>
<pre><code class="language-txt">1: index: 0, data: A
2: index: 1, data: B
3: index: 2, data: C
4: index: 3, data: D
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">0: 0─┐
     1─┐
1: 2─┘ │
       3
2: 4─┐ │
     5─┘
3: 6─┘
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">1: sig(0)
3: sig(1)
3: sig(1 + 4)
4: sig(3)
</code></pre>
<a class="header" href="#verifying-a-merkle-tree" id="verifying-a-merkle-tree"><h2>Verifying A Merkle Tree</h2></a>
<p>TODO</p>
<a class="header" href="#root-nodes" id="root-nodes"><h2>Root Nodes</h2></a>
<p>If the number of leaf nodes is a multiple of 2 the flat tree will only have a
single root. Otherwise it'll have more than one.</p>
<a class="header" href="#storage-format" id="storage-format"><h2>Storage Format</h2></a>
<p>The format of the each node in the Merkle Tree on disk is a series of 40 byte
buffers. The first 32 bytes is the hash. The next 8 bytes is the byte size of
the spanning tree.</p>
<p>The format for storing nodes is:</p>
<ul>
<li>32 byte header which starts with a magic number to indicate what type of file
it is.</li>
<li>Then a series of nodes, where each index in the sequence corresponds to a
position in the Flat Tree.</li>
</ul>
<p>To read the 6th node from disk (flat tree node <code>#5</code>), you'd use an offset into
the file of <code>32 + 5 * 40</code>, and then read <code>40</code> bytes. The first 32 bytes are the
hash. The last 8 bytes is the combined length of the data nodes <code>#4</code> and <code>#6</code> are
referencing. The length is encoded as <code>uint64</code> Big Endian.</p>
<a class="header" href="#references-1" id="references-1"><h2>References</h2></a>
<ul>
<li>https://gist.github.com/jimpick/54adc72f11f38f1fe4bc1d45d3981708</li>
<li>https://github.com/datrs/tree-index/issues/7#issuecomment-419086236</li>
</ul>
<a class="header" href="#bitfield" id="bitfield"><h1>Bitfield</h1></a>
<a class="header" href="#what-is-a-bitfield" id="what-is-a-bitfield"><h2>What is a bitfield?</h2></a>
<p>Space-efficient data structure used to figure out which data you have and what
data you don't. Meant to always be kept in memory because it's small enough.</p>
<p>At its core, bitfields are a way of efficiently describing sets of numbers. You
can think of them as a series of bits. When a number at a position is 1, it
means that position is in the set. If a number is 0, that position isn't.</p>
<a class="header" href="#example" id="example"><h3>Example</h3></a>
<pre><code class="language-txt">bits:  00101
index: 01234
</code></pre>
<p>The set above contains <code>2</code> and <code>4</code>. It's stored left to right, because that's
the way it's enumerated.</p>
<p>In Dat we use bitfields to describe which pieces of data we have, and which
pieces of data we don't. Also it's used internally to index data structures,
such as the Merkle Tree.</p>
<a class="header" href="#indexed-bitfields" id="indexed-bitfields"><h2>Indexed Bitfields</h2></a>
<p>The most common operations in Dat for bitfields is to either find a piece of
data that's missing, or checking if we have a piece of data.</p>
<p>Checking if we have a piece of data is straightforward, as all we have to do is
look in the bitfield in the position of the data and see if it's a <code>1</code>.</p>
<p>Finding a piece of data we're missing is a bit more tricky. Basically it'll
require a linear scan of the whole bitfield. In order to speed this up, we use
an Indexed Bitfield.</p>
<a class="header" href="#structure" id="structure"><h3>Structure</h3></a>
<p>At a high level Indexed Bitfields are a binary tree structure where each node is
made up out of 2 bits.</p>
<ul>
<li><code>11</code> indicates all bits under this node are <code>1</code>s.</li>
<li><code>00</code> indicates all bits under this node are <code>0</code>s.</li>
<li><code>10</code> indicates bits under this node are a mixture of <code>1</code>s and <code>0</code>s.</li>
<li><code>01</code> is currently unused and reserved for (possible) future purposes.</li>
</ul>
<p>We call this the Tree Index Scheme.</p>
<p>Consider this Indexed Bitfield, written as a sequence of bits:</p>
<pre><code class="language-txt">01011101000000
</code></pre>
<p>Because the bits are indexed as a flat-tree, we can print it as a tree
structure:</p>
<pre><code class="language-txt">       01
  01       00
01  11   00  00
</code></pre>
<p>By looking at the root node we can tell that there's nodes in the tree, but not
yet <em>which</em> nodes are in the tree. By going one level lower however, it becomes
clear that there's nodes in one side of the tree, but no nodes in the other side
of the tree. This means we only need to check the children of the left node to
find out exactly which nodes we have.</p>
<p>A fun fact here is also: a completely zeroed-out buffer is a valid Indexed
Bitfield - it just means it's completely empty.</p>
<a class="header" href="#optimizing-the-structure" id="optimizing-the-structure"><h3>Optimizing the Structure</h3></a>
<p>Looking at a byte and looking at a bit is the same cost in a computer. You want
to optimize for getting the most information possible when looking at a byte.</p>
<p>Therefore in order get the most performance out of our structure, we want to
construct our tree using bytes instead of pairs of bits.</p>
<p>Consider the following scheme. Given two bytes: <code>A</code> <code>B</code>. Take each of them, and
split each of them into pairs of two bits. We'll use <code>a1 a2 a3 a4</code> to indicate
the pairs in <code>A</code>. And <code>b1 b2 b3 b4</code> to indicate the pairs in <code>B</code>.</p>
<p>The parent of <code>A</code> and <code>B</code> is <code>C</code>. <code>C</code> is constructed by applying the Tree Index
Scheme to each pair of bits.</p>
<pre><code class="language-txt">                [a1 + a2, a3 + a4, b1 + b2, b3 + b4]
[a1, a2, a3, a4]                                    [b1, b2, b3, b4]
</code></pre>
<p>In the example above, we use the <code>+</code> operator to indicate the application of the
Tree Index Scheme.</p>
<p>In the future we might make this even more efficient using <code>SIMD</code> instructions,
which can operate on more bits at the same time.</p>
<a class="header" href="#lookup-tables" id="lookup-tables"><h2>Lookup Tables</h2></a>
<p>An efficient implementation of the previous scheme can be done using lookup
tables for values between between 0 and 256.</p>
<p>This is all solely for performance and completely optional. The important part
is that the indexing scheme is followed.</p>
<a class="header" href="#types-of-bitfields" id="types-of-bitfields"><h2>Types of Bitfields</h2></a>
<p>We have 3 bitfields:</p>
<ul>
<li><strong>Data Bitfield:</strong> Indicates which data you have, and which data you don't.</li>
<li><strong>Indexed Bitfield:</strong> Helps efficiently search through the Data Bitfield using
the Tree Index Scheme.</li>
<li><strong>Merkle Tree Bitfield:</strong> Indicates which nodes in the Merkle Tree you have,
and which nodes you don't.</li>
</ul>
<p>This means that whenever you update the Data Bitfield, you must also update
the Indexed Bitfield.</p>
<a class="header" href="#updating-a-byte" id="updating-a-byte"><h3>Updating a Byte</h3></a>
<p>If we want to set an index in a bitfield to <code>false</code>, it would mean we needed to
flip a bit to <code>0</code>. Because we can only operate on bytes, the easiest way to
achieve this is to apply a bitmask.</p>
<p>Consider the following lookup table, in binary notation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data_update = vec![
  0b01111111, // 127
  0b10111111, // 191
  0b11011111, // 223
  0b11101111, // 223
  0b11110111, // 247
  0b11111011, // 251
  0b11111101, // 253
  0b11111110, // 254
];
#}</code></pre></pre>
<p>There are 8 entries in this table, all of which have a different position of
which bit is set to zero. When you want to flip a bit to zero, you take the
index of the bit you want to flip, look up the entry in the table, and bitwise
AND the two numbers.</p>
<a class="header" href="#serialization" id="serialization"><h2>Serialization</h2></a>
<p>For every piece of data there's going to be 1 bit in the Data Bitfield. And
2 bits in the Merkle Tree Bitfield because there's a parent node and a leaf
node. There are going to be as many parents as there will be leaves.</p>
<p>Every time there's 16 bits in the Data Bitfield, the Indexed Bitfield needs 2
bits to indicate if it's all <code>1</code>s, <code>0</code>s, or a mixture. And 2 bits for the Tree
Index Scheme, totalling 4 bits in the Indexed Bitfield.</p>
<p>So this translates to the following ratios:</p>
<ul>
<li><strong>Data:</strong> 1024 bytes.</li>
<li><strong>Merkle Tree:</strong> 2048 bytes.</li>
<li><strong>Indexed Tree:</strong> 256 bytes.</li>
</ul>
<a class="header" href="#run-length-encoding" id="run-length-encoding"><h2>Run Length Encoding</h2></a>
<p>When sending data over the wire, we want to compress the bitfields further. An
efficient way of doing this is by using Run Length Encoding (RLE).
TODO: explain the module. For now read the README.</p>
<ul>
<li><a href="https://github.com/mafintosh/bitfield-rle">mafintosh/bitfield-rle</a></li>
</ul>
<a class="header" href="#storage" id="storage"><h1>Storage</h1></a>
<p>You can represent a binary tree in a simple flat list using the following
structure:</p>
<pre><code class="language-txt">      3
  1       5
0   2   4   6  ...
</code></pre>
<a class="header" href="#headers" id="headers"><h2>Headers</h2></a>
<p>All the files in Dat's Storage are considered SLEEP files. However, not all
files require a header. Only the files that have a variable algorithm (such as
hashing, signing) require a SLEEP header.</p>
<a class="header" href="#usage-in-dat" id="usage-in-dat"><h2>Usage in Dat</h2></a>
<p>When you append data, you basically update the Merkle Tree. Updating the Merkle
Tree creates a new Root Hash of the Merkle Tree. For security we need to sign
this Root Hash, so people can trust it's the new one.</p>
<p>It's important to know that everything in Hypercore is a byproduct of appending
data to the Feed. This includes Signatures, Hashes, Root Nodes and more.</p>
<a class="header" href="#types-of-storage" id="types-of-storage"><h3>Types of Storage</h3></a>
<ul>
<li><strong>data:</strong> The concatenated data that was appended to the feed.</li>
<li><strong>merkle tree:</strong> The hashes of the data, and hashes of hashes of data - stored
in a tree. Also stores the length of the data.</li>
<li><strong>signatures:</strong> We take the Root Hash of the Merkle Tree, and sign that one.</li>
<li><strong>bitfield:</strong> Space-efficient data structure used to figure out which data you
have and what data you don't.</li>
<li><strong>key:</strong> Ed25519 Public Key (part of a keypair).</li>
<li><strong>secret key:</strong> Ed25519 Secret Key (part of a keypair).</li>
</ul>
<p>When you produce a new Signature, the index for the Signature is the same index
as for the data you appended to the Feed.</p>
<a class="header" href="#random-access-storage" id="random-access-storage"><h2>Random Access Storage</h2></a>
<p>Hypercore supports multiple persistence backends through the
<code>random-access-storage</code> interface. Each storage backend adheres to a
standardized interface to write, read and delete ranges of bytes.</p>
<p>There are many different backends available, but generally all implementations
implement the following backends:</p>
<ul>
<li><code>random-access-memory</code>: stores bytes in-memory. Ideal for testing, and
providing an initial implementation.</li>
<li><code>random-access-disk</code>: stores bytes on disk. Generally useful as Hypercore's
first persistent backend.</li>
</ul>
<p>Because Hypercore and Dat support partially downloading data, a useful feature
is to implement <em>sparse persistence</em>. This means that we can write data into
memory or to disk with spaces in between, but without paying any cost.</p>
<p>For example if we want to write bytes 0 to 10, and bytes 9877 to 11000, the
space between 10 and 9877 should not cost us anything.</p>
<p>This is generally implemented using <em>pagers</em>. A pager is a vector (or array)
where each entry is a range. If we want to access a particular range, we lookup
the correct entry in the pager, and allocate it if needed. This way we preserve
space we don't use.</p>
<p>It's generally good to use 1kb pages when accessing memory, and 4kb pages when
accessing disk (SSD). This ensures that data will be written as continuous
chunks, which is good for performance.</p>
<a class="header" href="#implementation-guide" id="implementation-guide"><h1>Implementation Guide</h1></a>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<p>The following sections contain reference material you may find useful in your
Dat journey.</p>
<a class="header" href="#terminology" id="terminology"><h1>Terminology</h1></a>
<p>The following terms are used when describing the Dat Protocol.</p>
<a class="header" href="#terminology-currently-in-use" id="terminology-currently-in-use"><h2>Terminology Currently in Use</h2></a>
<ul>
<li><strong>feed:</strong> The main data structure in Hypercore. Append-only log that uses
multiple data structures and algorithms to safely store data.</li>
<li><strong>data:</strong> Atomic pieces of data that are written to the feed by users.</li>
<li><strong>keypair:</strong> An <code>Ed25519</code> keypair used to encrypt data with.</li>
<li><strong>signature:</strong> Certificate that proves a data structure was created by a
specific keypair.</li>
<li><strong>tree:</strong> A binary tree mapped as a <code>flat-tree</code> to keep an index of the
current data.</li>
<li><strong>flat-tree:</strong> Mapping of a series of integers to a binary tree structure.</li>
<li><strong>bitfield:</strong> Space-efficient data structure used to figure out which data you
have and what data you don't. Meant to always be kept in memory because it's
small enough.</li>
<li><strong>run-length-encoding (RLE):</strong> Basic compression scheme used to compress
bitfields when sending over the wire.</li>
<li><strong>parent node:</strong> A parent has two children under it, and is always
odd-numbered. Node 3 is the parent of 1 and 5.</li>
<li><strong>leaf node:</strong> A node with no children. A leaf node is always even-numbered.
Nodes 0, 2, 4, 6 and 8 are leaf nodes.</li>
<li><strong>sibling node:</strong> The other node that shares a parent with the current node.
For example nodes 4 and 6 are siblings.</li>
<li><strong>uncle node:</strong> A parent's sibling. Node 1 is the uncle of nodes 4 and 6.</li>
<li><strong>root node:</strong> A top-most node where the full tree under it is complete (e.g.
all parent nodes have 2 children). Node 3 is a root node.</li>
<li><strong>node span:</strong> The two nodes that are furthest away in the sub-tree. The span
of node 1 is <code>0, 2</code>. The span of node 3 is <code>0, 6</code>.</li>
<li><strong>right node span:</strong> The left-most node in the span. The right span of node 1
is 2. The right span of node 3 is 6.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
