<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="ch00-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="ch01-00-key-concepts.html"><strong aria-hidden="true">2.</strong> Key Concepts</a></li><li><ol class="section"><li><a href="ch01-01-flat-tree.html"><strong aria-hidden="true">2.1.</strong> Flat Tree</a></li><li><a href="ch01-02-merkle-tree.html"><strong aria-hidden="true">2.2.</strong> Merkle Tree</a></li><li><a href="ch01-03-bitfield.html"><strong aria-hidden="true">2.3.</strong> Bitfield</a></li><li><a href="ch01-04-storage.html"><strong aria-hidden="true">2.4.</strong> Storage</a></li></ol></li><li><a href="ch02-00-implementation-guide.html"><strong aria-hidden="true">3.</strong> Implementation Guide</a></li><li><ol class="section"><li><a href="ch02-01-flat-tree.html"><strong aria-hidden="true">3.1.</strong> Flat Tree</a></li><li><a href="ch02-02-merkle-tree-stream.html"><strong aria-hidden="true">3.2.</strong> Merkle Tree Stream</a></li><li><a href="ch02-03-memory-pager.html"><strong aria-hidden="true">3.3.</strong> Memory Pager</a></li></ol></li><li><a href="ch03-00-appendix.html"><strong aria-hidden="true">4.</strong> Appendix</a></li><li><ol class="section"><li><a href="ch03-01-terminology.html"><strong aria-hidden="true">4.1.</strong> A - Terminology</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to <em>The Dat Protocol</em>, a technical book about <a href="https://datproject.org/">The Dat
Project</a>. The Dat protocol is a p2p hypermedia
protocol. It provides public-key-addressed file archives which can be synced
securely and browsed on-demand.</p>
<h2><a class="header" href="#who-this-book-is-for" id="who-this-book-is-for">Who This Book Is For</a></h2>
<p>This book is written for people interested in understanding the details of the
Dat protocol, and potentially implementing parts of it themselves. We go into
details about the different components that make up the protocol, and provide
guidance on how to approach an implementation yourself.</p>
<p>This book is different from the <a href="https://www.datprotocol.com/deps/">Dat Enhancement Proposals
(DEPs)</a>. DEPs focus on creating
standardization and specification of the Dat protocol. This book focuses on
providing an introduction to key concepts, and guidance on how to implement
them.</p>
<h2><a class="header" href="#source-code" id="source-code">Source Code</a></h2>
<p>The source files from which this book is generated can be found on
<a href="https://github.com/datprotocol/book">GitHub</a>.</p>
<h1><a class="header" href="#key-concepts" id="key-concepts">Key Concepts</a></h1>
<p>In this section we'll introduce you to the conceptual components that make up
the Dat protocol. You don't need to know these to create your first Dat archive,
but they're essential if you're trying to understand what happens at the
protocol level.</p>
<h1><a class="header" href="#flat-tree" id="flat-tree">Flat Tree</a></h1>
<p>Flat Trees are the core data structure that power Dat's Hypercore feeds. They
allow us to deterministically represent a tree structure as a vector. This is
particularly useful because vectors map elegantly to disk and memory.</p>
<p>Because Flat Trees are deterministic and pre-computed, there is no overhead to
using them. In effect this means that Flat Trees are a specific way of indexing
into a vector more than they are their own data structure. This makes them
uniquely efficient and convenient to implement in a wide range of languages.</p>
<h2><a class="header" href="#thinking-about-flat-trees" id="thinking-about-flat-trees">Thinking About Flat Trees</a></h2>
<p>You can represent a binary tree in a simple flat list using the following
structure:</p>
<pre><code class="language-txt">      3
  1       5
0   2   4   6  ...
</code></pre>
<p>Let's rotate the tree on its side for notational purposes:</p>
<pre><code class="language-txt"> 0─┐
   1─┐
 2─┘ │
     3
 4─┐ │
   5─┘
 6─┘
</code></pre>
<p>Each number represents an <strong>index</strong> in a flat list. Given the tree:</p>
<pre><code class="language-txt"> D─┐
   B─┐
 E─┘ │
     A
 F─┐ │
   C─┘
 G─┘
</code></pre>
<p>The way this would be expressed in-memory would be as the list (vector):
<code>[D B E A F C G]</code> or <code>[0 1 2 3 4 5 6]</code>.</p>
<h2><a class="header" href="#depth" id="depth">Depth</a></h2>
<p>Indexes 0, 2, 4, 6 have a depth of 0. And indexes 1 and 5 have a depth of 1.</p>
<pre><code class="language-text">depth = 2  ^        3
depth = 1  |    1       5
depth = 0  |  0   2   4   6  ...
</code></pre>
<p>If we convert the graph to a chart we could express it as such:</p>
<pre><code class="language-text">depth = 0 | 0 2 4 6
depth = 1 | 1 5
depth = 2 | 3
depth = 3 |
</code></pre>
<p>Now let's add numbers up to 14:</p>
<pre><code class="language-text">depth = 0 | 0 2 4 6 8 10 12 14
depth = 1 | 1 5 9 13
depth = 2 | 3 11
depth = 3 | 7
</code></pre>
<h3><a class="header" href="#node-kinds" id="node-kinds">Node Kinds</a></h3>
<p>You might be noticing that the numbers at <code>depth = 0</code> is vastly greater than the
amount of numbers at every other depth. We refer to nodes at <code>depth = 0</code> as
<code>leaf nodes</code>, and nodes at every other depth as <code>parent nodes</code>.</p>
<pre><code class="language-text">leaf nodes   | 0 2 4 6 8 10 12 14
parent nodes | 1 3 5 7 9 11 13
</code></pre>
<p>An interesting aspect of flat trees is that the number of <code>leaf nodes</code> and
number of <code>parent nodes</code> is in perfect balance. This comes to an interesting
insight:</p>
<ul>
<li>All <strong>even indexes</strong> refer to <code>leaf nodes</code>.</li>
<li>All <strong>uneven indexes</strong> refer to <code>parent nodes</code>.</li>
</ul>
<p>The depth of a tree node can be calculated by counting the number of trailing 1s
a node has in binary notation.</p>
<pre><code class="language-txt">5 in binary = 101 (one trailing 1)
3 in binary = 011 (two trailing 1s)
4 in binary = 100 (zero trailing 1s)
</code></pre>
<h2><a class="header" href="#offset" id="offset">Offset</a></h2>
<p>When reading about flat-trees the word <code>offset</code> might regularly pop up. This
refers to the offset from the left hand side of the tree.</p>
<p>In the following tree the indexes with an offset of 0 are: <code>[0 1 3 7]</code>:</p>
<pre><code class="language-text">(0)┐
  (1)┐
 2─┘ │
    (3)┐
 4─┐ │ │
   5─┘ │
 6─┘   │
      (7)
</code></pre>
<p>In the next tree the indexes with an offset of 1 are: <code>[2 5 11]</code>:</p>
<pre><code class="language-text">  0──┐
     1──┐
 (2)─┘  │
        3──┐
  4──┐  │  │
    (5)─┘  │
  6──┘     │
           7
  8──┐     │
     9──┐  │
 10──┘  │  │
      (11)─┘
 12──┐  │
    13──┘
 14──┘
</code></pre>
<h2><a class="header" href="#relationships-between-nodes" id="relationships-between-nodes">Relationships Between Nodes</a></h2>
<p>When describing nodes we often also talk about the relationship between nodes.
This includes words such as <code>uncle</code>, and <code>parent</code>.</p>
<p>Take this example tree:</p>
<pre><code class="language-txt"> 0─┐
   1─┐
 2─┘ │
     3─┐
 4─┐ │ │
   5─┘ │
 6─┘   │
       7
 8
</code></pre>
<ul>
<li><strong>parent:</strong> A parent has two children under it, and is always odd-numbered.
Node 3 is the parent of 1 and 5.</li>
<li><strong>leaf:</strong> A node with no children. A leaf node is always even-numbered.
Nodes 0, 2, 4, 6 and 8 are leaf nodes.</li>
<li><strong>sibling:</strong> The other node that shares a parent with the current node. For
example nodes 4 and 6 are siblings.</li>
<li><strong>uncle:</strong> A parent's sibling. Node 1 is the uncle of nodes 4 and 6.</li>
<li><strong>root:</strong> A top-most node where the full tree under it is complete (e.g. all
parent nodes have 2 children). Node 3 is a root node.</li>
<li><strong>span:</strong> The two nodes that are furthest away in the sub-tree. The span of
node 1 is <code>0, 2</code>. The span of node 3 is <code>0, 6</code>.</li>
<li><strong>right span:</strong> The left-most node in the span. The right span of node 1 is 2.
The right span of node 3 is 6.</li>
</ul>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li>https://gist.github.com/jimpick/54adc72f11f38f1fe4bc1d45d3981708</li>
<li>https://github.com/jimpick/hypercore-simple-ipld/blob/master/tree-test.js</li>
<li>https://datatracker.ietf.org/doc/rfc7574/?include_text=1</li>
<li>https://www.datprotocol.com/deps/0002-hypercore/</li>
</ul>
<h1><a class="header" href="#merkle-tree" id="merkle-tree">Merkle Tree</a></h1>
<p>Merkle Trees in Dat are specialized <a href="./ch01-01-flat-tree">Flat Trees</a> that
contain the content of the archives.</p>
<p>In this section we'll cover how Merkle Trees work, and how we use them inside
Hypercore.</p>
<h2><a class="header" href="#what-are-merkle-trees" id="what-are-merkle-trees">What Are Merkle Trees?</a></h2>
<p>Wikipedia defines a Merkle Tree as:</p>
<blockquote>
<p>A hash tree or Merkle tree is a tree in which every leaf node is labelled with
the hash of a data block and every non-leaf node is labelled with the
cryptographic hash of the labels of its child nodes.</p>
</blockquote>
<p>In <code>flat-tree</code> terminology this means all leaf nodes (even numbers) contain
hashes of data, and all uneven numbers (parent nodes) contain hashes.</p>
<p>Take the following tree:</p>
<pre><code class="language-txt">  0──┐
     1──┐
  2──┘  │
        3
  4──┐  │
     5──┘
  6──┘
</code></pre>
<ul>
<li>Nodes 0, 2, 4, and 6 contain the hashes of data.</li>
<li>Node 1 contains the hash of hashes from nodes 0 and 2.</li>
<li>Node 5 contains the hash of hashes from nodes 4 and 6.</li>
<li>Node 3 contains the hash of hashes from nodes 1 and 5.</li>
</ul>
<h2><a class="header" href="#hypercore-files" id="hypercore-files">Hypercore Files</a></h2>
<p>A Hypercore's internal structure typically consist of these files:</p>
<ul>
<li><strong>data:</strong> a file containing the data added to the Hypercore.</li>
<li><strong>tree:</strong> a file containing the Merkle tree of hashes derived from the data.</li>
<li><strong>signatures:</strong> a file containing the cryptographic signatures of the hashes
in the tree file.</li>
<li><strong>bitfield:</strong> a file to keep track of which data we have locally, and which
data is part of the network.</li>
<li><strong>public key:</strong> a file containing the public key. This is used for verifying
content.</li>
<li><strong>secret key:</strong> a file containing the signing key. This is used for adding new
content, and is only available on Hypercores you've created.</li>
</ul>
<blockquote>
<p>The names we're using to refer to files here is also the way they're referred
to in Hypercore's specs and implementations. When inspecting a <code>.dat</code>
directory you'll see these terms used as suffixes. For example
as <code>content.tree</code>, or <code>metadata.signatures</code>.</p>
</blockquote>
<p>The tree file is responsible for verifying the integrity of the data that's
being appended to the feed.</p>
<p>The signature file is responsible for ensuring the integrity of the entire tree
at any given state. Every entry in the signature file verifies the current state
of the entire tree file.</p>
<blockquote>
<p>Not every Hypercore is the same. In most implementations of Dat it's possible
to choose how data is stored. For server applications it makes sense to store
it in a single file. But for desktop applications it can sometimes make sense
to store content directly on disk. For example in the case of (hyper)media
files.</p>
</blockquote>
<p>Let's look at how these files relate to each other to create a Hypercore feed.</p>
<h2><a class="header" href="#merkle-trees-in-theory" id="merkle-trees-in-theory">Merkle Trees In Theory</a></h2>
<p>Whenever data is added to Hypercore, a new entry is created in the data file. We
then hash the data, and write that hash to a tree file's leaf node. If the leaf
node has a sibling, the parent node's hash can be computed. If the new parent
node has a sibling, we can compute a new parent node above it. We recurse upward
until no more parent nodes can be computed, at which point we'll have reached a
root node.</p>
<p>When there are no more hashes left to compute, we gather all the root nodes in
the tree, concatenate them, hash them, and sign them with our private key. We
then store the signature in our signatures file at the same index of the leaf
node that was added.</p>
<p>This might all sound a little abstract though, so let's look at an example.</p>
<h2><a class="header" href="#merkle-trees-in-practice" id="merkle-trees-in-practice">Merkle Trees In Practice</a></h2>
<p>We're starting off with an empty Hypercore feed. We're planning to add 4 pieces
of data to it, one by one: <code>[A B C D]</code>.</p>
<h3><a class="header" href="#entry-1" id="entry-1">Entry 1</a></h3>
<p>Let's add our first piece of data to Hypercore. We insert the value &quot;A&quot; as our
first entry. In order, the following actions happen:</p>
<ol>
<li>We append the data to the data file.</li>
<li>We compute a hash (<code>#0</code>) from the data, and store it at index <code>0</code> in our tree file.</li>
<li>We gather all root nodes from our tree file (which is just the node at index
0 right now), and compute a cryptographic signature from the hash.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<p><strong>data</strong></p>
<pre><code class="language-txt">0: A
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">0: #0 = hash(data[0])
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">0: sig(#0)
</code></pre>
<h3><a class="header" href="#entry-2" id="entry-2">Entry 2</a></h3>
<p>Let's add our second entry to hypercore. We now have more nodes, which means
things are a little different:</p>
<ol>
<li>We append the data to the data file.</li>
<li>We compute a hash from the data (<code>#2</code>), and store it at index <code>1</code> in our tree file.</li>
<li>Because <code>#2</code> has a sibling hash, we compute a new parent hash (<code>#1</code>), and store
it at index <code>1</code>.</li>
<li>We gather all root nodes from our tree file, and compute a cryptographic
signature from the hash. The only root node currently available is <code>#1</code>. Note that while we compute <code>#1</code> from our tree file, we do not store it there. Only even-numbered hashes are stored in the tree file as the odd-numbered ones can be calculated from them.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<blockquote>
<p>When we talk about &quot;computing a parent hash&quot; it means we concatenate (<code>+</code>) the
hashes from both child nodes, and hash the result. Hashes are always the same
length, which means every node in the tree is the same length.</p>
</blockquote>
<p><strong>data</strong></p>
<pre><code class="language-txt">0: A
1: B
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">0: #0 = hash(data[0]) ─┐
                       #1 = hash(#0 + #2)
1: #2 = hash(data[1]) ─┘
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">0: sig(#0)
1: sig(#1)
</code></pre>
<h3><a class="header" href="#entry-3" id="entry-3">Entry 3</a></h3>
<p>So far so good. We're well on our way to building a full tree-structure! Let's
continue on our journey, and add our third entry: <code>C</code>.</p>
<ol>
<li>We append the third piece data to the data file at index <code>2</code>.</li>
<li>We compute a hash from the data (<code>#4</code>), and store it at index <code>2</code> in our tree file.</li>
<li>We now have two root hashes: <code>#1</code> and <code>#4</code>. So we concatenate them, hash the
result, and sign the result.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<p><strong>data</strong></p>
<pre><code class="language-txt">0: A
1: B
2: C
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">0: #0 = hash(data[0]) ─┐
                       #1 = hash(tree[0] + tree[1])
1: #2 = hash(data[1]) ─┘

2: #4 = hash(data[2])
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">0: sig(#0)
1: sig(#1)
2: sig(#1 + #4)
</code></pre>
<h3><a class="header" href="#entry-4" id="entry-4">Entry 4</a></h3>
<p>Let's add the final piece of data to our feed. This will balance out a tree, and
bring us back to only one root hash!</p>
<ol>
<li>We append the fourth piece data to the data file at index <code>3</code>.</li>
<li>We compute a hash from the data (<code>#6</code>), and store it at index <code>3</code> in our tree file.</li>
<li>Our only root hash is <code>#3</code>, so we sign it and compute the signature.</li>
<li>We append the signature to our signatures file.</li>
</ol>
<p><strong>data</strong></p>
<pre><code class="language-txt">0: A
1: B
2: C
3: D
</code></pre>
<p><strong>tree</strong></p>
<pre><code class="language-txt">0: #0 = hash(data[0]) ─┐
                       #1 = hash(#0 + #2) ─┐
1: #2 = hash(data[1]) ─┘                   │
                                           #3 = hash(#1 + #5)
2: #4 = hash(data[2]) ─┐                   │
                       #5 = hash(#4 + #6) ─┘
3: #6 = hash(data[3]) ─┘
</code></pre>
<p><strong>signatures</strong></p>
<pre><code class="language-txt">0: sig(#0)
1: sig(#1)
2: sig(#1 + #4)
3: sig(#3)
</code></pre>
<h2><a class="header" href="#verifying-a-merkle-tree" id="verifying-a-merkle-tree">Verifying A Merkle Tree</a></h2>
<p>TODO</p>
<h2><a class="header" href="#root-nodes" id="root-nodes">Root Nodes</a></h2>
<p>If the number of leaf nodes is a multiple of 2 the flat tree will only have a
single root. Otherwise it'll have more than one.</p>
<h2><a class="header" href="#storage-format" id="storage-format">Storage Format</a></h2>
<p>The format of the each node in the Merkle Tree on disk is a series of 40 byte
buffers. The first 32 bytes is the hash. The next 8 bytes is the byte size of
the spanning tree.</p>
<p>The format for storing nodes is:</p>
<ul>
<li>32 byte header which starts with a magic number to indicate what type of file
it is.</li>
<li>Then a series of nodes, where each index in the sequence corresponds to a
position in the Flat Tree.</li>
</ul>
<p>To read the 6th node from disk (flat tree node <code>#5</code>), you'd use an offset into
the file of <code>32 + 5 * 40</code>, and then read <code>40</code> bytes. The first 32 bytes are the
hash. The last 8 bytes is the combined length of the data nodes <code>#4</code> and <code>#6</code> are
referencing. The length is encoded as <code>uint64</code> Big Endian.</p>
<h2><a class="header" href="#references-1" id="references-1">References</a></h2>
<ul>
<li>https://gist.github.com/jimpick/54adc72f11f38f1fe4bc1d45d3981708</li>
<li>https://github.com/datrs/tree-index/issues/7#issuecomment-419086236</li>
</ul>
<h1><a class="header" href="#bitfield" id="bitfield">Bitfield</a></h1>
<h2><a class="header" href="#what-is-a-bitfield" id="what-is-a-bitfield">What is a bitfield?</a></h2>
<p>Space-efficient data structure used to figure out which data you have and what
data you don't. Meant to always be kept in memory because it's small enough.</p>
<p>At its core, bitfields are a way of efficiently describing sets of numbers. You
can think of them as a series of bits. When a number at a position is 1, it
means that position is in the set. If a number is 0, that position isn't.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<pre><code class="language-txt">bits:  00101
index: 01234
</code></pre>
<p>The set above contains <code>2</code> and <code>4</code>. It's stored left to right, because that's
the way it's enumerated.</p>
<p>In Dat we use bitfields to describe which pieces of data we have, and which
pieces of data we don't. Also it's used internally to index data structures,
such as the Merkle Tree.</p>
<h2><a class="header" href="#indexed-bitfields" id="indexed-bitfields">Indexed Bitfields</a></h2>
<p>The most common operations in Dat for bitfields is to either find a piece of
data that's missing, or checking if we have a piece of data.</p>
<p>Checking if we have a piece of data is straightforward, as all we have to do is
look in the bitfield in the position of the data and see if it's a <code>1</code>.</p>
<p>Finding a piece of data we're missing is a bit more tricky. Basically it'll
require a linear scan of the whole bitfield. In order to speed this up, we use
an Indexed Bitfield.</p>
<h3><a class="header" href="#structure" id="structure">Structure</a></h3>
<p>At a high level Indexed Bitfields are a binary tree structure where each node is
made up out of 2 bits.</p>
<ul>
<li><code>11</code> indicates all bits under this node are <code>1</code>s.</li>
<li><code>00</code> indicates all bits under this node are <code>0</code>s.</li>
<li><code>10</code> indicates bits under this node are a mixture of <code>1</code>s and <code>0</code>s.</li>
<li><code>01</code> is currently unused and reserved for (possible) future purposes.</li>
</ul>
<p>We call this the Tree Index Scheme.</p>
<p>Consider this Indexed Bitfield, written as a sequence of bits:</p>
<pre><code class="language-txt">01011101000000
</code></pre>
<p>Because the bits are indexed as a flat-tree, we can print it as a tree
structure:</p>
<pre><code class="language-txt">       01
  01       00
01  11   00  00
</code></pre>
<p>By looking at the root node we can tell that there's nodes in the tree, but not
yet <em>which</em> nodes are in the tree. By going one level lower however, it becomes
clear that there's nodes in one side of the tree, but no nodes in the other side
of the tree. This means we only need to check the children of the left node to
find out exactly which nodes we have.</p>
<p>A fun fact here is also: a completely zeroed-out buffer is a valid Indexed
Bitfield - it just means it's completely empty.</p>
<h3><a class="header" href="#optimizing-the-structure" id="optimizing-the-structure">Optimizing the Structure</a></h3>
<p>Looking at a byte and looking at a bit is the same cost in a computer. You want
to optimize for getting the most information possible when looking at a byte.</p>
<p>Therefore in order to get the most performance out of our structure, we want to
construct our tree using bytes instead of pairs of bits.</p>
<p>Consider the following scheme. Given two bytes: <code>A</code> <code>B</code>. Take each of them, and
split each of them into pairs of two bits. We'll use <code>a1 a2 a3 a4</code> to indicate
the pairs in <code>A</code>. And <code>b1 b2 b3 b4</code> to indicate the pairs in <code>B</code>.</p>
<p>The parent of <code>A</code> and <code>B</code> is <code>C</code>. <code>C</code> is constructed by applying the Tree Index
Scheme to each pair of bits.</p>
<pre><code class="language-txt">                [a1 + a2, a3 + a4, b1 + b2, b3 + b4]
[a1, a2, a3, a4]                                    [b1, b2, b3, b4]
</code></pre>
<p>In the example above, we use the <code>+</code> operator to indicate the application of the
Tree Index Scheme.</p>
<p>In the future we might make this even more efficient using <code>SIMD</code> instructions,
which can operate on more bits at the same time.</p>
<h2><a class="header" href="#lookup-tables" id="lookup-tables">Lookup Tables</a></h2>
<p>An efficient implementation of the previous scheme can be done using lookup
tables for values between between 0 and 256.</p>
<p>This is all solely for performance and completely optional. The important part
is that the indexing scheme is followed.</p>
<h2><a class="header" href="#types-of-bitfields" id="types-of-bitfields">Types of Bitfields</a></h2>
<p>We have 3 bitfields:</p>
<ul>
<li><strong>Data Bitfield:</strong> Indicates which data you have, and which data you don't.</li>
<li><strong>Indexed Bitfield:</strong> Helps efficiently search through the Data Bitfield using
the Tree Index Scheme.</li>
<li><strong>Merkle Tree Bitfield:</strong> Indicates which nodes in the Merkle Tree you have,
and which nodes you don't.</li>
</ul>
<p>This means that whenever you update the Data Bitfield, you must also update
the Indexed Bitfield.</p>
<h3><a class="header" href="#updating-a-byte" id="updating-a-byte">Updating a Byte</a></h3>
<p>If we want to set an index in a bitfield to <code>false</code>, it would mean we needed to
flip a bit to <code>0</code>. Because we can only operate on bytes, the easiest way to
achieve this is to apply a bitmask.</p>
<p>Consider the following lookup table, in binary notation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data_update = vec![
  0b01111111, // 127
  0b10111111, // 191
  0b11011111, // 223
  0b11101111, // 239
  0b11110111, // 247
  0b11111011, // 251
  0b11111101, // 253
  0b11111110, // 254
];
#}</code></pre></pre>
<p>There are 8 entries in this table, all of which have a different position of
which bit is set to zero. When you want to flip a bit to zero, you take the
index of the bit you want to flip, look up the entry in the table, and bitwise
AND the two numbers.</p>
<h2><a class="header" href="#serialization" id="serialization">Serialization</a></h2>
<p>For every piece of data there's going to be 1 bit in the Data Bitfield. And
2 bits in the Merkle Tree Bitfield because there's a parent node and a leaf
node. There are going to be as many parents as there will be leaves.</p>
<p>Every time there's 16 bits in the Data Bitfield, the Indexed Bitfield needs 2
bits to indicate if it's all <code>1</code>s, <code>0</code>s, or a mixture. And 2 bits for the Tree
Index Scheme, totalling 4 bits in the Indexed Bitfield.</p>
<p>So this translates to the following ratios:</p>
<ul>
<li><strong>Data:</strong> 1024 bytes.</li>
<li><strong>Merkle Tree:</strong> 2048 bytes.</li>
<li><strong>Indexed Tree:</strong> 256 bytes.</li>
</ul>
<h2><a class="header" href="#run-length-encoding" id="run-length-encoding">Run Length Encoding</a></h2>
<p>When sending data over the wire, we want to compress the bitfields further. An
efficient way of doing this is by using Run Length Encoding (RLE).
TODO: explain the module. For now read the README.</p>
<ul>
<li><a href="https://github.com/mafintosh/bitfield-rle">mafintosh/bitfield-rle</a></li>
</ul>
<h1><a class="header" href="#storage" id="storage">Storage</a></h1>
<p>You can represent a binary tree in a simple flat list using the following
structure:</p>
<pre><code class="language-txt">      3
  1       5
0   2   4   6  ...
</code></pre>
<h2><a class="header" href="#headers" id="headers">Headers</a></h2>
<p>All the files in Dat's Storage are considered SLEEP files. However, not all
files require a header. Only the files that have a variable algorithm (such as
hashing, signing) require a SLEEP header.</p>
<h2><a class="header" href="#usage-in-dat" id="usage-in-dat">Usage in Dat</a></h2>
<p>When you append data, you basically update the Merkle Tree. Updating the Merkle
Tree creates a new Root Hash of the Merkle Tree. For security we need to sign
this Root Hash, so people can trust it's the new one.</p>
<p>It's important to know that everything in Hypercore is a byproduct of appending
data to the Feed. This includes Signatures, Hashes, Root Nodes and more.</p>
<h3><a class="header" href="#types-of-storage" id="types-of-storage">Types of Storage</a></h3>
<ul>
<li><strong>data:</strong> The concatenated data that was appended to the feed.</li>
<li><strong>merkle tree:</strong> The hashes of the data, and hashes of hashes of data - stored
in a tree. Also stores the length of the data.</li>
<li><strong>signatures:</strong> We take the Root Hash of the Merkle Tree, and sign that one.</li>
<li><strong>bitfield:</strong> Space-efficient data structure used to figure out which data you
have and what data you don't.</li>
<li><strong>key:</strong> Ed25519 Public Key (part of a keypair).</li>
<li><strong>secret key:</strong> Ed25519 Secret Key (part of a keypair).</li>
</ul>
<p>When you produce a new Signature, the index for the Signature is the same index
as for the data you appended to the Feed.</p>
<h2><a class="header" href="#random-access-storage" id="random-access-storage">Random Access Storage</a></h2>
<p>Hypercore supports multiple persistence backends through the
<code>random-access-storage</code> interface. Each storage backend adheres to a
standardized interface to write, read and delete ranges of bytes.</p>
<p>There are many different backends available, but generally all implementations
implement the following backends:</p>
<ul>
<li><code>random-access-memory</code>: stores bytes in-memory. Ideal for testing, and
providing an initial implementation.</li>
<li><code>random-access-disk</code>: stores bytes on disk. Generally useful as Hypercore's
first persistent backend.</li>
</ul>
<p>Because Hypercore and Dat support partially downloading data, a useful feature
is to implement <em>sparse persistence</em>. This means that we can write data into
memory or to disk with spaces in between, but without paying any cost.</p>
<p>For example if we want to write bytes 0 to 10, and bytes 9877 to 11000, the
space between 10 and 9877 should not cost us anything.</p>
<p>This is generally implemented using <em>pagers</em>. A pager is a vector (or array)
where each entry is a range. If we want to access a particular range, we lookup
the correct entry in the pager, and allocate it if needed. This way we preserve
space we don't use.</p>
<p>It's generally good to use 1kb pages when accessing memory, and 4kb pages when
accessing disk (SSD). This ensures that data will be written as continuous
chunks, which is good for performance.</p>
<h1><a class="header" href="#implementation-guide" id="implementation-guide">Implementation Guide</a></h1>
<h1><a class="header" href="#flat-tree-1" id="flat-tree-1">flat-tree</a></h1>
<p><code>flat-tree</code> is one of the first modules that should be implemented for the Dat
protocol. See <a href="/ch01-01-flat-tree.html">Key Concepts: Flat Tree</a> for an overview
of how Flat Trees work.</p>
<h2><a class="header" href="#core-api" id="core-api">Core API</a></h2>
<p>The core flat-tree API consists of several methods that can calculate the nodes
relative to each other.</p>
<h3><a class="header" href="#children" id="children">Children</a></h3>
<p>Returns both children of a node. It cannot return any children when querying a
leaf node, so the result must be a <code>Null</code>, <code>Maybe</code>, or <code>Option</code> type, depending
on the language used.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn children_with_depth(i: usize, depth: usize) -&gt; Option&lt;(usize, usize)&gt;
#}</code></pre></pre>
<h3><a class="header" href="#count" id="count">count</a></h3>
<p>Returns how many nodes are under the tree that the node spans.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn count_with_depth(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#depth-1" id="depth-1">depth</a></h3>
<p>Returns the depth of a node at a given index.
is removed from the left-most node at its current depth</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn depth(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#full_roots" id="full_roots">full_roots</a></h3>
<p>Returns a list of all the full roots (subtrees where all nodes have either 2 or
0 children).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn full_roots(i: usize) -&gt; Vec&lt;usize&gt;{
#}</code></pre></pre>
<h3><a class="header" href="#index" id="index">index</a></h3>
<p>Return the index for a node at a given depth and offset.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn index(depth: usize, offset: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#left_child" id="left_child">left_child</a></h3>
<p>Return the left child of the node at index.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn left_child(i: usize) -&gt; Option&lt;usize&gt;
#}</code></pre></pre>
<h3><a class="header" href="#left_span" id="left_span">left_span</a></h3>
<p>Returns the left-most child of the node at index.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn left_span(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#offset-1" id="offset-1">offset</a></h3>
<p>Returns the offset of a node at a given index. The offset of a node is how far
it is removed from the left-most node at its current depth</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn offset(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#parent" id="parent">parent</a></h3>
<p>Returns the parent of a node.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn parent(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#right_child" id="right_child">right_child</a></h3>
<p>Return the right child of the node at index.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn right_child(i: usize) -&gt; Option&lt;usize&gt;
#}</code></pre></pre>
<h3><a class="header" href="#right_span" id="right_span">right_span</a></h3>
<p>Returns the right-most child of the node at index.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn right_span(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#left_span-1" id="left_span-1">left_span</a></h3>
<p>Returns the left-most child of the node at index.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn right_span(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#sibling" id="sibling">sibling</a></h3>
<p>Returns the node that shares the same parent node.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn sibling(i: usize) -&gt; usize
#}</code></pre></pre>
<h3><a class="header" href="#spans" id="spans">spans</a></h3>
<p>Returns a pair of the left-most node in the tree, and the right-most node in the
tree.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn spans(i: usize) -&gt; (usize, usize)
#}</code></pre></pre>
<h3><a class="header" href="#uncle" id="uncle">uncle</a></h3>
<p>Returns the parent's sibling node.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn uncle(i: usize) -&gt; usize
#}</code></pre></pre>
<h2><a class="header" href="#iterator-api" id="iterator-api">Iterator API</a></h2>
<p>Some upstream modules require stateful traversal of the tree. It can be
convenient to expose a stateful iterator module as part of <code>flat-tree</code> for those
cases.</p>
<p>The iterator should be a constructor that takes an initial index, and exposes
methods to move to child nodes, parent nodes, etc. The iterator should also
expose the index so it can be stored or used for other computations.</p>
<h2><a class="header" href="#optimizations" id="optimizations">Optimizations</a></h2>
<h3><a class="header" href="#calculate-depth" id="calculate-depth">Calculate Depth</a></h3>
<p>The depth of a node can be calculated by counting the number of tailing zeros in
a number. Languages such as Rust expose <code>&lt;num&gt;.trailing_zeros()</code> which counts
the amount of zeros at the end of a number (<code>cttz</code> intrinsic). By combining a
bitwise negation (<code>!</code> or <code>NOT</code> operation) with the <code>.trailing_zeros()</code> method,
the amount of trailing ones can be counted. On x86 machines this should be
around 3 instructions when inlined.</p>
<h3><a class="header" href="#re-use-the-depth-parameter" id="re-use-the-depth-parameter">Re-use the depth parameter</a></h3>
<p>Sometimes when calling multiple functions on the same index, depending on the
execution environment it can be efficient to reuse the <code>depth</code> parameter.</p>
<p>However if the optimized depth method is used, there's no strict need to expose
the <code>with_depth*</code> methods, as the compiler will detect the duplicate
computation, and remove it anyway. Mileage may vary, but this technique has been
tested on LLVM output for the Rust version. In the worst case there might be
penalty of up 3 instructions per call, which seems like a negligible penalty.</p>
<h3><a class="header" href="#calculate-children" id="calculate-children">Calculate children</a></h3>
<p>Calculating whether a node has children can be sped up by quickly checking if a
number is even or uneven. If a number is uneven, it's already guaranteed to be a
child node, so it can't have child nodes.</p>
<h3><a class="header" href="#spans-1" id="spans-1">Spans</a></h3>
<p>Similarly for spans. If an even number is targeted, it is at the bottom of the
tree, so it will only span itself. Therefore it's easy to implement an <code>is_even</code>
check, and return the index that was passed in if it's true.</p>
<h2><a class="header" href="#full-roots" id="full-roots">Full Roots</a></h2>
<p>To prevent allocations <code>full-roots</code> could also write to either a pre-allocated
vector, or a stack-allocated collection instead.</p>
<h1><a class="header" href="#merkle-tree-stream" id="merkle-tree-stream">Merkle Tree Stream</a></h1>
<p>We covered how Dat's Merkle Trees work in the <a href="/ch01-02-merkle-tree.html">Merkle Tree
Chapter</a>. In this chapter we'll discuss how to
implement it, and what to look out for when optimizing.</p>
<h2><a class="header" href="#core-abstraction" id="core-abstraction">Core Abstraction</a></h2>
<p>At its core, the merkle tree stream is a stateful algorithm. It takes data in
(leaf nodes), hashes it, and computes as many parent hashes as it can.</p>
<p>At its core this can be expressed as a stateful class that has a <code>.append()</code> or
<code>.next()</code> method. Internally it keeps track of three properties:</p>
<ul>
<li>An index to keep track of how far along in the sequence we are.</li>
<li>A vector of hashes.</li>
<li>The current roots.</li>
</ul>
<p>To prevent allocations, both the vector of hashes and current roots could be
passed in externally, but this is not a requirement.</p>
<h2><a class="header" href="#methods" id="methods">Methods</a></h2>
<p><code>merkle-tree-stream</code> should operate as a generic structure without tying itself
to any particular hash function. This means that when creating an instance, the
methods have to be passed in. The following methods are generally required:</p>
<ul>
<li><strong>leaf:</strong> takes data in, and produces a hash of the data.</li>
<li><strong>parent:</strong> takes two hashes, and produces a new hash.</li>
</ul>
<p>In strictly typed languages, both the input <code>data</code>, and <code>hash</code> need to be passed
as type parameters into the generic function. In dynamically typed languages,
both can generally be expressed as byte array.</p>
<h2><a class="header" href="#async" id="async">Async</a></h2>
<p>In practice it's perfectly fine to write the stream as a synchronous method.
For most implementations of Dat I/O typically tends to be the bottleneck, but on
a live system that might not always be the case (e.g. contention with other
resources). So to improve the overall performance of <code>merkle-tree-stream</code>, it
can be useful to schedule work over multiple cores.</p>
<p>The first candidate for parallelization is the hashing of the leaf nodes. Unlike
the parent nodes, the hashes in the leaf nodes are just functions of data, so
they can be freely scheduled on different cores without any problem.</p>
<p>A bigger challenge is when creating hashes for the parent nodes. Because each
parent depends on having two child nodes, it means you can't compute a parent
node before its children have been computed. This means that that if we're only
adding a single entry to the stream it cannot be parallelized, because each
hash depends on the hash that came before it.</p>
<p>Take the following tree:</p>
<pre><code class="language-txt">  0──┐
     1──┐
  2──┘  │
        3
  4──┐  │
     5──┘
  6──┘
</code></pre>
<p>Computing the hashes of <code>[0 2 4 6]</code> are parallizable. Once those are complete,
<code>[1 5]</code> can be computed. And then <code>[3]</code> can be computed.</p>
<p>The exact underlying mechanisms for storing and synchronizing nodes is a topic
that could use more research. But starting with a read-write lock around the
internal vector of hashes, and creating a task queue seems like the right
starting point.</p>
<h2><a class="header" href="#references-2" id="references-2">References</a></h2>
<ul>
<li><a href="https://github.com/datrs/merkle-tree-stream">datrs/merkle-tree-stream</a></li>
<li><a href="https://github.com/mafintosh/merkle-tree-stream">mafintosh/merkle-tree-stream</a></li>
</ul>
<h1><a class="header" href="#memory-pager" id="memory-pager">memory-pager</a></h1>
<p>Data in Hypercore streams can be replicated out of order. This means that you
could both have the first message in a feed, and the millionth message in a
feed. To ensure that we don't allocate space for a million messages when we only
have two we make use of a data structure called a <em>memory pager</em>.</p>
<p>Memory pagers work by having a vector of pointers to fixed-sized byte buffers.
Each buffer (or page, if you will) is only allocated once there it has data that
needs to be written into it.</p>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<h3><a class="header" href="#writing" id="writing">Writing</a></h3>
<p>Say we have a memory pager with pages that are 4 kilobytes long each. The
initial state would be:</p>
<pre><code class="language-txt">[]
</code></pre>
<p>All we have is an empty list with no values.</p>
<blockquote>
<p>4 kilobytes is a reasonable default for pages, as it maps directly to most
operating system's page internal paging structures. This means that this can
generally efficiently be allocated &amp; cleared.</p>
</blockquote>
<p>Let's say we want to write the 2000th byte. We need to figure out which page
this will be on. We can do this by dividing the index by the page size, and the
resulting number (integer) is the page we want to index. E.g. <code>2000 / 1024</code> =
<code>1</code>.</p>
<blockquote>
<p>In languages that don't support integer division, the equivalent of
<code>Math.floor()</code> should be called on the resulting value.</p>
</blockquote>
<p>Now that we have the right page number, we need to find the right index on the
page. We can do this by using the modulo operator. E.g. <code>2000 % (1024 - 1)</code>
results in index <code>997</code>. We subtract 1 from the page size because the first entry
is located a position 0, not position 1.</p>
<p>Putting this together, we need to write the 997th byte on the second page (index
1). This would look as:</p>
<pre><code class="language-txt">[
  None,
  Some(Vec), // 1024 bytes
]
</code></pre>
<p>The first page isn't allocated so we put a <code>None</code> (or <code>null</code>) value there. The
second page (index 1) <em>is</em> allocated, so we keep a pointer into the buffer. All
gaps in between bytes are kept as None types.</p>
<h2><a class="header" href="#reading" id="reading">Reading</a></h2>
<p>Reading values from the pager can be split up into two operations:</p>
<ul>
<li>reading a value from an empty page</li>
<li>reading a value from an existent page</li>
</ul>
<p>It's generally recommended that any value read from the memory pager can be an
empty variant (<code>None</code> or <code>null</code>), as it might not have been written yet. This is
similar to accessing values in most vector implementations.</p>
<p>When a value is read from an empty page, if the page is empty the resulting
value will be empty too.</p>
<p>If the page exists, the index into the buffer must be calculated (see the
Writing section), and that value can be returned.</p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<p>We can get the page by dividing the index by the page size:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let page_num = index / (page_size - 1);
let page = get_page(page_num); // get the page from our list.
#}</code></pre></pre>
<p>To get the adjusted index into the page, we need to translate the page index:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let page_index = index % (page_size - 1);
#}</code></pre></pre>
<p>Putting these together:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn set(index: usize, value: T) {
  let page_num = index / (self.page_size - 1);
  let page = match self.pages.get(page_num) {
    Some(page) =&gt; page,
    None =&gt; /* allocate a new page and return it */,
  }
  let page_index = index % (page_size - 1);
  page[page_index] = value;
}
#}</code></pre></pre>
<h2><a class="header" href="#references-3" id="references-3">References</a></h2>
<ul>
<li><a href="https://github.com/mafintosh/memory-pager">mafintosh/memory-pager</a></li>
<li><a href="https://github.com/datrs/memory-pager">datrs/memory-pager</a></li>
</ul>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your
Dat journey.</p>
<h1><a class="header" href="#terminology" id="terminology">Terminology</a></h1>
<p>The following terms are used when describing the Dat Protocol.</p>
<h2><a class="header" href="#terminology-currently-in-use" id="terminology-currently-in-use">Terminology Currently in Use</a></h2>
<ul>
<li><strong>feed:</strong> The main data structure in Hypercore. Append-only log that uses
multiple data structures and algorithms to safely store data.</li>
<li><strong>data:</strong> Atomic pieces of data that are written to the feed by users.</li>
<li><strong>keypair:</strong> An <code>Ed25519</code> keypair used to encrypt data with.</li>
<li><strong>signature:</strong> Certificate that proves a data structure was created by a
specific keypair.</li>
<li><strong>tree:</strong> A binary tree mapped as a <code>flat-tree</code> to keep an index of the
current data.</li>
<li><strong>flat-tree:</strong> Mapping of a series of integers to a binary tree structure.</li>
<li><strong>bitfield:</strong> Space-efficient data structure used to figure out which data you
have and what data you don't. Meant to always be kept in memory because it's
small enough.</li>
<li><strong>run-length-encoding (RLE):</strong> Basic compression scheme used to compress
bitfields when sending over the wire.</li>
<li><strong>parent node:</strong> A parent has two children under it, and is always
odd-numbered. Node 3 is the parent of 1 and 5.</li>
<li><strong>leaf node:</strong> A node with no children. A leaf node is always even-numbered.
Nodes 0, 2, 4, 6 and 8 are leaf nodes.</li>
<li><strong>sibling node:</strong> The other node that shares a parent with the current node.
For example nodes 4 and 6 are siblings.</li>
<li><strong>uncle node:</strong> A parent's sibling. Node 1 is the uncle of nodes 4 and 6.</li>
<li><strong>root node:</strong> A top-most node where the full tree under it is complete (e.g.
all parent nodes have 2 children). Node 3 is a root node.</li>
<li><strong>node span:</strong> The two nodes that are furthest away in the sub-tree. The span
of node 1 is <code>0, 2</code>. The span of node 3 is <code>0, 6</code>.</li>
<li><strong>right node span:</strong> The left-most node in the span. The right span of node 1
is 2. The right span of node 3 is 6.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
